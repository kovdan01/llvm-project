; NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py UTC_ARGS: --version 5
; RUN: llc < %s -mtriple arm64e-apple-darwin             -verify-machineinstrs -stop-after=finalize-isel -global-isel=0 \
; RUN:     | FileCheck %s --check-prefixes=DAGISEL
; RUN: llc < %s -mtriple arm64e-apple-darwin             -verify-machineinstrs -stop-after=finalize-isel -global-isel=1 -global-isel-abort=1 \
; RUN:     | FileCheck %s --check-prefixes=GISEL
; RUN: llc < %s -mtriple aarch64-linux-gnu -mattr=+pauth -verify-machineinstrs -stop-after=finalize-isel -global-isel=0 \
; RUN:     | FileCheck %s --check-prefixes=DAGISEL
; RUN: llc < %s -mtriple aarch64-linux-gnu -mattr=+pauth -verify-machineinstrs -stop-after=finalize-isel -global-isel=1 -global-isel-abort=1 \
; RUN:     | FileCheck %s --check-prefixes=GISEL

; Check MIR produced by the instruction selector to validate properties that
; cannot be reliably tested by only inspecting the final asm output.

@discvar = dso_local global i64 0

; FIXME Should we remove this file?

; Make sure various forms of "ptrauth" call bundles are properly normalized
; to a full, three-operand form and then passed as the operands of PAC pseudo.
; Specifically, make sure that "ptrauth"(i64 key, i64 disc) is handled as
; "ptrauth"(i64 key, i64 disc, i64 0) when disc is uint16 constant and as
; "ptrauth"(i64 key, i64 0, i64 disc) otherwise. This is important to prevent
; substitution of the immediate modifier.
;
; MIR output of the instruction selector is inspected, as it is hard to reliably
; distinguish MOVKXi immediately followed by a pseudo from a standalone pseudo
; instruction carrying address and immediate modifiers in its separate operands
; by only observing the final asm output.

define i64 @small_imm_disc_optimized(i64 %addr) {
  ; DAGISEL-LABEL: name: small_imm_disc_optimized
  ; DAGISEL: bb.0.entry:
  ; DAGISEL-NEXT:   liveins: $x0
  ; DAGISEL-NEXT: {{  $}}
  ; DAGISEL-NEXT:   [[COPY:%[0-9]+]]:gpr64 = COPY $x0
  ; DAGISEL-NEXT:   [[PAC:%[0-9]+]]:gpr64 = PAC [[COPY]], 2, 42, $noreg, implicit-def dead $x16, implicit-def dead $x17
  ; DAGISEL-NEXT:   $x0 = COPY [[PAC]]
  ; DAGISEL-NEXT:   RET_ReallyLR implicit $x0
  ;
  ; GISEL-LABEL: name: small_imm_disc_optimized
  ; GISEL: bb.1.entry:
  ; GISEL-NEXT:   liveins: $x0
  ; GISEL-NEXT: {{  $}}
  ; GISEL-NEXT:   [[COPY:%[0-9]+]]:gpr64 = COPY $x0
  ; GISEL-NEXT:   [[PAC:%[0-9]+]]:gpr64 = PAC [[COPY]], 2, 42, $noreg, implicit-def dead $x16, implicit-def dead $x17
  ; GISEL-NEXT:   $x0 = COPY [[PAC]]
  ; GISEL-NEXT:   RET_ReallyLR implicit $x0
entry:
  %signed = call i64 @llvm.ptrauth.sign(i64 %addr) [ "ptrauth"(i64 2, i64 42) ]
  ret i64 %signed
}

define i64 @small_imm_disc_non_optimized(i64 %addr) noinline optnone {
  ; DAGISEL-LABEL: name: small_imm_disc_non_optimized
  ; DAGISEL: bb.0.entry:
  ; DAGISEL-NEXT:   liveins: $x0
  ; DAGISEL-NEXT: {{  $}}
  ; DAGISEL-NEXT:   [[COPY:%[0-9]+]]:gpr64 = COPY $x0
  ; DAGISEL-NEXT:   [[COPY1:%[0-9]+]]:gpr64 = COPY killed [[COPY]]
  ; DAGISEL-NEXT:   [[PAC:%[0-9]+]]:gpr64 = PAC [[COPY1]], 2, 42, $noreg, implicit-def dead $x16, implicit-def dead $x17
  ; DAGISEL-NEXT:   [[COPY3:%[0-9]+]]:gpr64all = COPY [[PAC]]
  ; DAGISEL-NEXT:   $x0 = COPY [[COPY3]]
  ; DAGISEL-NEXT:   RET_ReallyLR implicit $x0
  ;
  ; GISEL-LABEL: name: small_imm_disc_non_optimized
  ; GISEL: bb.1.entry:
  ; GISEL-NEXT:   liveins: $x0
  ; GISEL-NEXT: {{  $}}
  ; GISEL-NEXT:   [[COPY:%[0-9]+]]:gpr64 = COPY $x0
  ; GISEL-NEXT:   [[PAC:%[0-9]+]]:gpr64 = PAC [[COPY]], 2, 42, $noreg, implicit-def dead $x16, implicit-def dead $x17
  ; GISEL-NEXT:   $x0 = COPY [[PAC]]
  ; GISEL-NEXT:   RET_ReallyLR implicit $x0
entry:
  %signed = call i64 @llvm.ptrauth.sign(i64 %addr) [ "ptrauth"(i64 2, i64 42) ]
  ret i64 %signed
}

define i64 @large_imm_disc(i64 %addr) {
  ; DAGISEL-LABEL: name: large_imm_disc
  ; DAGISEL: bb.0.entry:
  ; DAGISEL-NEXT:   liveins: $x0
  ; DAGISEL-NEXT: {{  $}}
  ; DAGISEL-NEXT:   [[COPY:%[0-9]+]]:gpr64 = COPY $x0
  ; DAGISEL-NEXT:   [[MOVi32imm:%[0-9]+]]:gpr32 = MOVi32imm 12345678
  ; DAGISEL-NEXT:   [[SUBREG_TO_REG:%[0-9]+]]:gpr64noip = SUBREG_TO_REG 0, killed [[MOVi32imm]], %subreg.sub_32
  ; DAGISEL-NEXT:   [[PAC:%[0-9]+]]:gpr64 = PAC [[COPY]], 2, 0, killed [[SUBREG_TO_REG]], implicit-def dead $x16, implicit-def dead $x17
  ; DAGISEL-NEXT:   $x0 = COPY [[PAC]]
  ; DAGISEL-NEXT:   RET_ReallyLR implicit $x0
  ;
  ; GISEL-LABEL: name: large_imm_disc
  ; GISEL: bb.1.entry:
  ; GISEL-NEXT:   liveins: $x0
  ; GISEL-NEXT: {{  $}}
  ; GISEL-NEXT:   [[COPY:%[0-9]+]]:gpr64 = COPY $x0
  ; GISEL-NEXT:   [[MOVi32imm:%[0-9]+]]:gpr32 = MOVi32imm 12345678
  ; GISEL-NEXT:   [[SUBREG_TO_REG:%[0-9]+]]:gpr64noip = SUBREG_TO_REG 0, [[MOVi32imm]], %subreg.sub_32
  ; GISEL-NEXT:   [[PAC:%[0-9]+]]:gpr64 = PAC [[COPY]], 2, 0, [[SUBREG_TO_REG]], implicit-def dead $x16, implicit-def dead $x17
  ; GISEL-NEXT:   $x0 = COPY [[PAC]]
  ; GISEL-NEXT:   RET_ReallyLR implicit $x0
entry:
  %signed = call i64 @llvm.ptrauth.sign(i64 %addr) [ "ptrauth"(i64 2, i64 12345678) ]
  ret i64 %signed
}

define i64 @blended_disc(i64 %addr) {
  ; DAGISEL-LABEL: name: blended_disc
  ; DAGISEL: bb.0.entry:
  ; DAGISEL-NEXT:   liveins: $x0
  ; DAGISEL-NEXT: {{  $}}
  ; DAGISEL-NEXT:   [[COPY:%[0-9]+]]:gpr64 = COPY $x0
  ; DAGISEL-NEXT:   [[ADRP:%[0-9]+]]:gpr64common = ADRP target-flags(aarch64-page) @discvar
  ; DAGISEL-NEXT:   [[LDRXui:%[0-9]+]]:gpr64noip = LDRXui killed [[ADRP]], target-flags(aarch64-pageoff, aarch64-nc) @discvar :: (dereferenceable load (s64) from @discvar)
  ; DAGISEL-NEXT:   [[PAC:%[0-9]+]]:gpr64 = PAC [[COPY]], 2, 42, killed [[LDRXui]], implicit-def dead $x16, implicit-def dead $x17
  ; DAGISEL-NEXT:   $x0 = COPY [[PAC]]
  ; DAGISEL-NEXT:   RET_ReallyLR implicit $x0
  ;
  ; GISEL-LABEL: name: blended_disc
  ; GISEL: bb.1.entry:
  ; GISEL-NEXT:   liveins: $x0
  ; GISEL-NEXT: {{  $}}
  ; GISEL-NEXT:   [[COPY:%[0-9]+]]:gpr64 = COPY $x0
  ; GISEL-NEXT:   [[ADRP:%[0-9]+]]:gpr64common = ADRP target-flags(aarch64-page) @discvar
  ; GISEL-NEXT:   [[LDRXui:%[0-9]+]]:gpr64noip = LDRXui [[ADRP]], target-flags(aarch64-pageoff, aarch64-nc) @discvar :: (dereferenceable load (s64) from @discvar)
  ; GISEL-NEXT:   [[PAC:%[0-9]+]]:gpr64 = PAC [[COPY]], 2, 42, [[LDRXui]], implicit-def dead $x16, implicit-def dead $x17
  ; GISEL-NEXT:   $x0 = COPY [[PAC]]
  ; GISEL-NEXT:   RET_ReallyLR implicit $x0
entry:
  %addrdisc = load i64, ptr @discvar
  %signed = call i64 @llvm.ptrauth.sign(i64 %addr) [ "ptrauth"(i64 2, i64 %addrdisc, i64 42) ]
  ret i64 %signed
}
